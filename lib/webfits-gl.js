// Generated by CoffeeScript 1.4.0
(function() {
  var Api, BaseApi, ColorMaps, Shaders, WebFITS, version,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (this.astro == null) {
    this.astro = {};
  }

  WebFITS = {};

  WebFITS.version = '0.4.2';

  this.astro.WebFITS = WebFITS;

  BaseApi = (function() {

    function BaseApi(el, dimension) {
      var canvasStyle, overlayStyle, parentStyle;
      this.el = el;
      this.wheelHandler = __bind(this.wheelHandler, this);

      this._reset();
      this.width = this.height = dimension;
      this.canvas = document.createElement('canvas');
      this.canvas.setAttribute('width', this.width);
      this.canvas.setAttribute('height', this.height);
      this.canvas.setAttribute('class', 'visualization');
      this.overlay = document.createElement('canvas');
      this.overlay.setAttribute('width', this.width);
      this.overlay.setAttribute('height', this.height);
      this.overlay.setAttribute('class', 'overlay');
      this.overlayCtx = this.overlay.getContext('2d');
      this.el.appendChild(this.canvas);
      this.el.appendChild(this.overlay);
      this.nImages = 1;
      this.lookup = {};
      if (!this.getContext()) {
        return null;
      }
      this.offsetLeft = this.canvas.offsetLeft;
      this.offsetTop = this.canvas.offsetTop;
      parentStyle = this.canvas.parentElement.style;
      parentStyle.width = "" + this.canvas.width + "px";
      parentStyle.height = "" + this.canvas.height + "px";
      parentStyle.overflow = 'hidden';
      parentStyle.backgroundColor = '#252525';
      parentStyle.position = 'relative';
      canvasStyle = this.canvas.style;
      overlayStyle = this.overlay.style;
      canvasStyle.position = 'absolute';
      overlayStyle.position = 'absolute';
      overlayStyle.pointerEvents = 'none';
      this.xOffset = -this.width / 2;
      this.yOffset = -this.height / 2;
      this.xOldOffset = this.xOffset;
      this.yOldOffset = this.yOffset;
      this.drag = false;
      this.zoom = 2 / this.width;
      this.minZoom = this.zoom / 8;
      this.maxZoom = 20 * this.zoom;
      this.zoomX = this.zoom;
      this.zoomY = this.zoom;
      this.crosshair = false;
    }

    BaseApi.prototype.drawCrosshair = function() {
      this.overlay.width = this.overlay.width;
      this.overlayCtx.lineWidth = 1;
      this.overlayCtx.strokeStyle = '#0071e5';
      this.overlayCtx.moveTo(0, this.yCurrent);
      this.overlayCtx.lineTo(this.width, this.yCurrent);
      this.overlayCtx.moveTo(this.xCurrent, 0);
      this.overlayCtx.lineTo(this.xCurrent, this.height);
      return this.overlayCtx.stroke();
    };

    BaseApi.prototype.setupControls = function(callbacks, opts) {
      var _onmousedown, _onmousemove, _onmouseout, _onmouseover, _onmouseup,
        _this = this;
      if (callbacks == null) {
        callbacks = null;
      }
      if (opts == null) {
        opts = null;
      }
      _onmousedown = function(e) {
        _this.drag = true;
        _this.xOldOffset = _this.xOffset;
        _this.yOldOffset = _this.yOffset;
        _this.xMouseDown = e.clientX;
        return _this.yMouseDown = e.clientY;
      };
      _onmouseup = function(e) {
        var xDelta, yDelta;
        _this.drag = false;
        if (_this.xMouseDown == null) {
          return null;
        }
        xDelta = e.clientX - _this.xMouseDown;
        yDelta = e.clientY - _this.yMouseDown;
        _this.xOffset = _this.xOldOffset + (xDelta / _this.width / _this.zoom * 2.0);
        _this.yOffset = _this.yOldOffset - (yDelta / _this.height / _this.zoom * 2.0);
        return _this.draw();
      };
      _onmousemove = function(e) {
        var xDelta, yDelta;
        if (_this.crosshair) {
          _this.xCurrent = e.layerX;
          _this.yCurrent = e.layerY;
          _this.drawCrosshair();
        }
        if (!_this.drag) {
          return;
        }
        xDelta = e.clientX - _this.xMouseDown;
        yDelta = e.clientY - _this.yMouseDown;
        _this.xOffset = _this.xOldOffset + (xDelta / _this.width / _this.zoom * 2.0);
        _this.yOffset = _this.yOldOffset - (yDelta / _this.height / _this.zoom * 2.0);
        return _this.draw();
      };
      _onmouseout = function(e) {
        return _this.drag = false;
      };
      _onmouseover = function(e) {
        return _this.drag = false;
      };
      if ((callbacks != null ? callbacks.onzoom : void 0) != null) {
        this.zoomCallback = callbacks.onzoom;
      }
      if ((callbacks != null ? callbacks.onmousedown : void 0) != null) {
        this.canvas.onmousedown = function(e) {
          _onmousedown(e);
          return callbacks.onmousedown.call(_this, opts, e);
        };
      } else {
        this.canvas.onmousedown = function(e) {
          return _onmousedown(e);
        };
      }
      if ((callbacks != null ? callbacks.onmouseup : void 0) != null) {
        this.canvas.onmouseup = function(e) {
          _onmouseup(e);
          return callbacks.onmouseup.call(_this, opts, e);
        };
      } else {
        this.canvas.onmouseup = function(e) {
          return _onmouseup(e);
        };
      }
      if ((callbacks != null ? callbacks.onmousemove : void 0) != null) {
        this.canvas.onmousemove = function(e) {
          var offsetX, offsetY, x, xDelta, y, yDelta;
          _onmousemove(e);
          offsetX = e.clientX - _this.offsetLeft;
          offsetY = e.clientY - _this.offsetTop;
          xDelta = -1 * (_this.width / 2 - offsetX) / _this.width / _this.zoom * 2.0;
          yDelta = (_this.height / 2 - offsetY) / _this.height / _this.zoom * 2.0;
          x = ((-1 * (_this.xOffset + 0.5)) + xDelta) + 1.5 << 0;
          y = ((-1 * (_this.yOffset + 0.5)) + yDelta) + 1.5 << 0;
          return callbacks.onmousemove.call(_this, x, y, opts, e);
        };
      } else {
        this.canvas.onmousemove = function(e) {
          return _onmousemove(e);
        };
      }
      if ((callbacks != null ? callbacks.onmouseout : void 0) != null) {
        this.canvas.onmouseout = function(e) {
          _onmouseout(e);
          return callbacks.onmouseout.call(_this, opts, e);
        };
      } else {
        this.canvas.onmouseout = function(e) {
          return _onmouseout(e);
        };
      }
      if ((callbacks != null ? callbacks.onmouseover : void 0) != null) {
        this.canvas.onmouseover = function(e) {
          _onmouseover(e);
          return callbacks.onmouseover.call(_this, opts, e);
        };
      } else {
        this.canvas.onmouseover = function(e) {
          return _onmouseover(e);
        };
      }
      this.canvas.addEventListener('mousewheel', this.wheelHandler, false);
      return this.canvas.addEventListener('wheel', this.wheelHandler, false);
    };

    BaseApi.prototype.wheelHandler = function(e) {
      var factor;
      e.preventDefault();
      factor = e.shiftKey ? 1.01 : 1.1;
      this.zoom *= (e.wheelDelta || e.deltaY) < 0 ? 1 / factor : factor;
      this.zoom = this.zoom > this.maxZoom ? this.maxZoom : this.zoom;
      this.zoom = this.zoom < this.minZoom ? this.minZoom : this.zoom;
      return typeof this.zoomCallback === "function" ? this.zoomCallback() : void 0;
    };

    BaseApi.prototype.setCursor = function(type) {
      this.overlay.width = this.overlay.width;
      if (type === 'crosshair') {
        return this.crosshair = true;
      } else {
        return this.crosshair = false;
      }
    };

    return BaseApi;

  })();

  this.astro.WebFITS.BaseApi = BaseApi;

  Shaders = {
    vertex: ["attribute vec2 a_position;", "attribute vec2 a_textureCoord;", "uniform vec2 u_offset;", "uniform float u_scale;", "varying vec2 v_textureCoord;", "void main() {", "vec2 position = a_position + u_offset;", "position = position * u_scale;", "gl_Position = vec4(position, 0.0, 1.0);", "v_textureCoord = a_textureCoord;", "}"].join("\n"),
    linear: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform sampler2D uColorMap;", "uniform float uColorMapIndex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = u_extent[0];", "float max = u_extent[1];", "float x = (pixel_v.r - min) / (max - min);", "gl_FragColor = texture2D( uColorMap, vec2(x, uColorMapIndex / 70.0) );", "}"].join("\n"),
    logarithm: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform sampler2D uColorMap;", "uniform float uColorMapIndex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "float logarithm(float value) {", "return log(value / 0.05 + 1.0) / log(1.0 / 0.05 + 1.0);", "}", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = u_extent[0];", "float max = logarithm(u_extent[1] - min);", "float logMin = logarithm(0.0);", "float pixel = logarithm(pixel_v[0] - min);", "float x = (pixel - logMin) / (max - logMin);", "gl_FragColor = texture2D( uColorMap, vec2(x, uColorMapIndex / 70.0) );", "}"].join("\n"),
    sqrt: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform sampler2D uColorMap;", "uniform float uColorMapIndex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = u_extent[0];", "float max = u_extent[1] - min;", "float x = sqrt( (pixel_v[0] - min) / max);", "gl_FragColor = texture2D( uColorMap, vec2(x, uColorMapIndex / 70.0) );", "}"].join("\n"),
    arcsinh: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform sampler2D uColorMap;", "uniform float uColorMapIndex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "float arcsinh(float value) {", "return log(value + sqrt(1.0 + value * value));", "}", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = 0.0;", "float max = arcsinh( u_extent[1] - u_extent[0] );", "float x = arcsinh( pixel_v[0] - u_extent[0] ) / max;", "gl_FragColor = texture2D( uColorMap, vec2(x, uColorMapIndex / 70.0) );", "}"].join("\n"),
    power: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform sampler2D uColorMap;", "uniform float uColorMapIndex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = u_extent[0];", "float max = pow(u_extent[1] - min, 2.0);", "float pixel = pow(pixel_v[0] - min, 2.0);", "float x = pixel / max;", "gl_FragColor = texture2D( uColorMap, vec2(x, uColorMapIndex / 70.0) );", "}"].join("\n"),
    color: ["precision mediump float;", "uniform sampler2D u_tex0;", "uniform sampler2D u_tex1;", "uniform sampler2D u_tex2;", "uniform float u_r_scale;", "uniform float u_g_scale;", "uniform float u_b_scale;", "uniform float u_r_calibration;", "uniform float u_g_calibration;", "uniform float u_b_calibration;", "uniform float u_alpha;", "uniform float u_Q;", "varying vec2 v_textureCoord;", "float arcsinh(float value) {", "return log(value + sqrt(1.0 + value * value));", "}", "void main() {", "vec4 pixel_v_r = texture2D(u_tex0, v_textureCoord);", "vec4 pixel_v_g = texture2D(u_tex1, v_textureCoord);", "vec4 pixel_v_b = texture2D(u_tex2, v_textureCoord);", "float r = (pixel_v_r[0]) * u_r_calibration * u_r_scale;", "float g = (pixel_v_g[0]) * u_g_calibration * u_g_scale;", "float b = (pixel_v_b[0]) * u_b_calibration * u_b_scale;", "float I = r + g + b + 1e-10;", "float factor = arcsinh(u_alpha * u_Q * I) / (u_Q * I);", "float R = clamp(r * factor, 0.0, 1.0);", "float G = clamp(g * factor, 0.0, 1.0);", "float B = clamp(b * factor, 0.0, 1.0);", "gl_FragColor = vec4(R, G, B, 1.0);", "}"].join("\n")
  };

  this.astro.WebFITS.Shaders = Shaders;

  ColorMaps = {
    base64: "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",
    Accent: 70,
    Blues: 69,
    BrBG: 68,
    BuGn: 67,
    BuPu: 66,
    CMRmap: 65,
    Dark2: 64,
    GnBu: 63,
    Greens: 62,
    Greys: 61,
    OrRd: 60,
    Oranges: 59,
    PRGn: 58,
    Paired: 57,
    Pastel1: 56,
    Pastel2: 55,
    PiYG: 54,
    PuBuGn: 53,
    PuBu: 52,
    PuOr: 51,
    PuRd: 50,
    Purples: 49,
    RdBu: 48,
    RdGy: 47,
    RdPu: 46,
    RdYlBu: 45,
    RdYlGn: 44,
    Reds: 43,
    Set1: 42,
    Set2: 41,
    Set3: 40,
    Spectral: 39,
    YlGnBu: 38,
    YlGn: 37,
    YlOrBr: 36,
    YlOrRd: 35,
    afmhot: 34,
    autumn: 33,
    binary: 32,
    bone: 31,
    brg: 30,
    bwr: 29,
    cool: 28,
    coolwarm: 27,
    copper: 26,
    cubehelix: 25,
    flag: 24,
    gist_earth: 23,
    gist_gray: 22,
    gist_heat: 21,
    gist_ncar: 20,
    gistainbow: 19,
    gist_stern: 18,
    gist_yarg: 17,
    gnuplot2: 16,
    gnuplot: 15,
    gray: 14,
    hot: 13,
    hsv: 12,
    jet: 11,
    ocean: 10,
    pink: 9,
    prism: 8,
    rainbow: 7,
    seismic: 6,
    spectral: 5,
    spring: 4,
    summer: 3,
    terrain: 2,
    winter: 1
  };

  this.astro.WebFITS.ColorMaps = ColorMaps;

  BaseApi = this.astro.WebFITS.BaseApi;

  Shaders = this.astro.WebFITS.Shaders;

  ColorMaps = this.astro.WebFITS.ColorMaps;

  Api = (function(_super) {

    __extends(Api, _super);

    function Api() {
      return Api.__super__.constructor.apply(this, arguments);
    }

    Api.prototype.fShaders = ['linear', 'logarithm', 'sqrt', 'arcsinh', 'power', 'color'];

    Api.prototype.grayMap = 32;

    Api.prototype._reset = function() {
      this.programs = {};
      this.textures = {};
      this.buffers = [];
      return this.shaders = [];
    };

    Api.prototype._getExtension = function() {
      return this.ctx.getExtension('OES_texture_float');
    };

    Api.prototype._loadShader = function(source, type) {
      var compiled, ctx, lastError, shader;
      ctx = this.ctx;
      shader = ctx.createShader(type);
      ctx.shaderSource(shader, source);
      ctx.compileShader(shader);
      compiled = ctx.getShaderParameter(shader, ctx.COMPILE_STATUS);
      if (!compiled) {
        lastError = ctx.getShaderInfoLog(shader);
        throw "Error compiling shader " + shader + ": " + lastError;
        ctx.deleteShader(shader);
        return null;
      }
      this.shaders.push(shader);
      return shader;
    };

    Api.prototype._createProgram = function(vshader, fshader) {
      var ctx, linked, program;
      ctx = this.ctx;
      program = ctx.createProgram();
      ctx.attachShader(program, vshader);
      ctx.attachShader(program, fshader);
      ctx.linkProgram(program);
      linked = ctx.getProgramParameter(program, ctx.LINK_STATUS);
      if (!linked) {
        throw "Error in program linking: " + (ctx.getProgramInfoLog(program));
        ctx.deleteProgram(program);
        return null;
      }
      return program;
    };

    Api.prototype._setRectangle = function(ctx, width, height) {
      var x1, x2, y1, y2, _ref, _ref1;
      _ref = [0, 0 + width], x1 = _ref[0], x2 = _ref[1];
      _ref1 = [0, 0 + height], y1 = _ref1[0], y2 = _ref1[1];
      return ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), ctx.STATIC_DRAW);
    };

    Api.prototype._updateUniforms = function(program) {
      var offsetLocation, scaleLocation;
      offsetLocation = this.ctx.getUniformLocation(program, 'u_offset');
      scaleLocation = this.ctx.getUniformLocation(program, 'u_scale');
      this.ctx.uniform2f(offsetLocation, this.xOffset, this.yOffset);
      return this.ctx.uniform1f(scaleLocation, this.zoom);
    };

    Api.prototype.getContext = function() {
      var buffer, colorIndexLocation, ctx, ext, fragShader, height, index, key, name, offsetLocation, positionLocation, program, scaleLocation, texCoordBuffer, texCoordLocation, vertexShader, width, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      _ref = ['webgl', 'experimental-webgl'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        try {
          ctx = this.canvas.getContext(name);
          width = this.canvas.width;
          height = this.canvas.height;
          ctx.viewport(0, 0, width, height);
        } catch (e) {

        }
        if (ctx) {
          break;
        }
      }
      if (!ctx) {
        return null;
      }
      this.ctx = ctx;
      ext = this._getExtension();
      if (!ext) {
        return null;
      }
      vertexShader = this._loadShader(Shaders.vertex, ctx.VERTEX_SHADER);
      if (!vertexShader) {
        return null;
      }
      _ref1 = this.fShaders;
      for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
        key = _ref1[index];
        fragShader = this._loadShader(Shaders[key], ctx.FRAGMENT_SHADER);
        if (!fragShader) {
          return null;
        }
        this.programs[key] = this._createProgram(vertexShader, fragShader);
        if (!this.programs[key]) {
          return null;
        }
      }
      _ref2 = this.programs;
      for (key in _ref2) {
        program = _ref2[key];
        ctx.useProgram(program);
        positionLocation = ctx.getAttribLocation(program, 'a_position');
        texCoordLocation = ctx.getAttribLocation(program, 'a_textureCoord');
        offsetLocation = ctx.getUniformLocation(program, 'u_offset');
        scaleLocation = ctx.getUniformLocation(program, 'u_scale');
        colorIndexLocation = ctx.getUniformLocation(program, 'uColorMapIndex');
        ctx.uniform2f(offsetLocation, -width / 2, -height / 2);
        ctx.uniform1f(scaleLocation, 2 / width);
        ctx.uniform1f(colorIndexLocation, ColorMaps.binary);
      }
      this.currentProgram = this.programs.linear;
      texCoordBuffer = ctx.createBuffer();
      ctx.bindBuffer(ctx.ARRAY_BUFFER, texCoordBuffer);
      ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), ctx.STATIC_DRAW);
      ctx.enableVertexAttribArray(texCoordLocation);
      ctx.vertexAttribPointer(texCoordLocation, 2, ctx.FLOAT, false, 0, 0);
      buffer = ctx.createBuffer();
      ctx.bindBuffer(ctx.ARRAY_BUFFER, buffer);
      ctx.enableVertexAttribArray(positionLocation);
      ctx.vertexAttribPointer(positionLocation, 2, ctx.FLOAT, false, 0, 0);
      this.buffers.push(texCoordBuffer);
      this.buffers.push(buffer);
      this.setupColorMapTexture();
      return ctx;
    };

    Api.prototype.setupColorMapTexture = function() {
      var ctx, img,
        _this = this;
      ctx = this.ctx;
      this._setRectangle(ctx, 256, 70);
      img = new Image();
      img.onload = function(e) {
        var location, program, stretch, texture, _i, _len, _ref;
        ctx.activeTexture(ctx.TEXTURE0);
        texture = ctx.createTexture();
        ctx.bindTexture(ctx.TEXTURE_2D, texture);
        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);
        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);
        ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGB, ctx.RGB, ctx.UNSIGNED_BYTE, img);
        _ref = ['linear', 'logarithm', 'sqrt', 'arcsinh', 'power'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          stretch = _ref[_i];
          program = _this.programs[stretch];
          ctx.useProgram(program);
          location = ctx.getUniformLocation(program, 'uColorMap');
          ctx.uniform1i(location, 0);
        }
        ctx.useProgram(_this.currentProgram);
        return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
      };
      return img.src = "data:image/png;base64," + ColorMaps.base64;
    };

    Api.prototype.setColorMap = function(name) {
      var cmaps, ctx, location, program, stretch, _i, _len, _ref;
      ctx = this.ctx;
      cmaps = Object.keys(ColorMaps);
      cmaps.shift();
      name = cmaps.indexOf(name) > -1 ? name : 'binary';
      _ref = ['linear', 'logarithm', 'sqrt', 'arcsinh', 'power'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stretch = _ref[_i];
        program = this.programs[stretch];
        ctx.useProgram(program);
        location = ctx.getUniformLocation(program, 'uColorMapIndex');
        ctx.uniform1f(location, ColorMaps[name]);
      }
      ctx.useProgram(this.currentProgram);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.loadImage = function(identifier, arr, width, height) {
      var ctx, index, texture;
      ctx = this.ctx;
      this._setRectangle(ctx, width, height);
      index = this.nImages;
      this.lookup[identifier] = this.nImages;
      ctx.activeTexture(ctx.TEXTURE0 + this.nImages);
      texture = ctx.createTexture();
      ctx.bindTexture(ctx.TEXTURE_2D, texture);
      ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
      ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
      ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);
      ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);
      ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.LUMINANCE, width, height, 0, ctx.LUMINANCE, ctx.FLOAT, new Float32Array(arr));
      if (this.currentImage == null) {
        this.currentImage = identifier;
      }
      this.textures[identifier] = texture;
      return this.nImages += 1;
    };

    Api.prototype.setImage = function(identifier) {
      var index, location;
      index = this.lookup[identifier];
      this.ctx.activeTexture(this.ctx.TEXTURE0 + index);
      location = this.ctx.getUniformLocation(this.currentProgram, "u_tex");
      this.ctx.uniform1i(location, index);
      return this.currentImage = identifier;
    };

    Api.prototype.setStretch = function(stretch) {
      this.currentProgram = this.programs[stretch];
      this.ctx.useProgram(this.currentProgram);
      this.setImage(this.currentImage);
      return this.draw();
    };

    Api.prototype.setExtent = function(min, max) {
      var ctx, location, program, stretch, _i, _len, _ref;
      ctx = this.ctx;
      _ref = ['linear', 'logarithm', 'sqrt', 'arcsinh', 'power'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stretch = _ref[_i];
        program = this.programs[stretch];
        ctx.useProgram(program);
        location = ctx.getUniformLocation(program, 'u_extent');
        ctx.uniform2f(location, min, max);
      }
      ctx.useProgram(this.currentProgram);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setScales = function(r, g, b) {
      var ctx, location, program;
      ctx = this.ctx;
      program = this.programs.color;
      ctx.useProgram(program);
      location = ctx.getUniformLocation(program, "u_r_scale");
      ctx.uniform1f(location, r);
      location = ctx.getUniformLocation(program, "u_g_scale");
      ctx.uniform1f(location, g);
      location = ctx.getUniformLocation(program, "u_b_scale");
      ctx.uniform1f(location, b);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setCalibrations = function(r, g, b) {
      var ctx, location;
      ctx = this.ctx;
      ctx.useProgram(this.programs.color);
      location = ctx.getUniformLocation(this.programs.color, 'u_r_calibration');
      ctx.uniform1f(location, r);
      location = ctx.getUniformLocation(this.programs.color, 'u_g_calibration');
      ctx.uniform1f(location, g);
      location = ctx.getUniformLocation(this.programs.color, 'u_b_calibration');
      ctx.uniform1f(location, b);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setAlpha = function(value) {
      var ctx, location;
      ctx = this.ctx;
      ctx.useProgram(this.programs.color);
      location = ctx.getUniformLocation(this.programs.color, 'u_alpha');
      ctx.uniform1f(location, value);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setQ = function(value) {
      var ctx, location;
      ctx = this.ctx;
      ctx.useProgram(this.programs.color);
      location = ctx.getUniformLocation(this.programs.color, 'u_Q');
      ctx.uniform1f(location, value);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.draw = function() {
      this._updateUniforms(this.currentProgram);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.drawColor = function(r, g, b) {
      var ctx, location, program;
      ctx = this.ctx;
      ctx.clear(ctx.COLOR_BUFFER_BIT);
      program = this.currentProgram = this.programs.color;
      ctx.useProgram(program);
      location = ctx.getUniformLocation(program, "u_tex0");
      ctx.uniform1i(location, this.lookup[r]);
      location = ctx.getUniformLocation(program, "u_tex1");
      ctx.uniform1i(location, this.lookup[g]);
      location = ctx.getUniformLocation(program, "u_tex2");
      ctx.uniform1i(location, this.lookup[b]);
      return this.draw();
    };

    Api.prototype.wheelHandler = function(e) {
      var location;
      Api.__super__.wheelHandler.apply(this, arguments);
      location = this.ctx.getUniformLocation(this.currentProgram, 'u_scale');
      this.ctx.uniform1f(location, this.zoom);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.getXOffset = function() {
      return this.xOffset;
    };

    Api.prototype.getYOffset = function() {
      return this.yOffset;
    };

    Api.prototype.getZoom = function() {
      return this.zoom;
    };

    Api.prototype.teardown = function() {
      var buffer, ctx, key, program, shader, texture, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      ctx = this.ctx;
      _ref = this.textures;
      for (key in _ref) {
        texture = _ref[key];
        ctx.deleteTexture(texture);
      }
      _ref1 = this.buffers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        buffer = _ref1[_i];
        ctx.deleteBuffer(buffer);
      }
      _ref2 = this.shaders;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        shader = _ref2[_j];
        ctx.deleteShader(shader);
      }
      _ref3 = this.programs;
      for (key in _ref3) {
        program = _ref3[key];
        ctx.deleteProgram(program);
      }
      this.el.removeChild(this.canvas);
      this.ctx = void 0;
      return this._reset();
    };

    return Api;

  })(BaseApi);

  version = this.astro.WebFITS.version;

  this.astro.WebFITS = Api;

  this.astro.WebFITS.version = version;

}).call(this);
