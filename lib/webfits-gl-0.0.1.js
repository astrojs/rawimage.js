// Generated by CoffeeScript 1.4.0
(function() {
  var Api, BaseApi, Shaders, WebFITS,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (this.astro == null) {
    this.astro = {};
  }

  WebFITS = {};

  WebFITS.version = '0.0.1';

  this.astro.WebFITS = WebFITS;

  BaseApi = (function() {

    function BaseApi(elem, width, height) {
      this.width = width;
      this.height = height;
      this.wheelHandler = __bind(this.wheelHandler, this);

      this.setupMouseInteraction = __bind(this.setupMouseInteraction, this);

      this.canvas = document.createElement('canvas');
      this.canvas.setAttribute('width', this.width);
      this.canvas.setAttribute('height', this.height);
      elem.appendChild(this.canvas);
    }

    BaseApi.prototype.setGlobalExtent = function(MINIMUM, MAXIMUM) {
      this.MINIMUM = MINIMUM;
      this.MAXIMUM = MAXIMUM;
    };

    BaseApi.prototype.setupMouseInteraction = function() {
      var _this = this;
      this.xOffset = -this.width / 2;
      this.yOffset = -this.height / 2;
      this.xOldOffset = this.xOffset;
      this.yOldOffset = this.yOffset;
      this.drag = false;
      this.zoom = 2 / this.width;
      this.minZoom = this.zoom;
      this.maxZoom = 12 * this.zoom;
      this.zoomX = this.zoom;
      this.zoomY = this.zoom;
      this.canvas.onmousedown = function(e) {
        _this.drag = true;
        _this.xOldOffset = _this.xOffset;
        _this.yOldOffset = _this.yOffset;
        _this.xMouseDown = e.clientX;
        return _this.yMouseDown = e.clientY;
      };
      this.canvas.onmouseup = function(e) {
        var xDelta, yDelta;
        _this.drag = false;
        if (_this.xMouseDown == null) {
          return null;
        }
        xDelta = e.clientX - _this.xMouseDown;
        yDelta = e.clientY - _this.yMouseDown;
        _this.xOffset = _this.xOldOffset + (xDelta / _this.width / _this.zoom * 2.0);
        _this.yOffset = _this.yOldOffset - (yDelta / _this.height / _this.zoom * 2.0);
        return _this.draw();
      };
      this.canvas.onmousemove = function(e) {
        var xDelta, yDelta;
        if (!_this.drag) {
          return;
        }
        xDelta = e.clientX - _this.xMouseDown;
        yDelta = e.clientY - _this.yMouseDown;
        _this.xOffset = _this.xOldOffset + (xDelta / _this.width / _this.zoom * 2.0);
        _this.yOffset = _this.yOldOffset - (yDelta / _this.height / _this.zoom * 2.0);
        return _this.draw();
      };
      this.canvas.onmouseout = function(e) {
        return _this.drag = false;
      };
      this.canvas.onmouseover = function(e) {
        return _this.drag = false;
      };
      this.canvas.addEventListener('mousewheel', this.wheelHandler, false);
      return this.canvas.addEventListener('DOMMouseScroll', this.wheelHandler, false);
    };

    BaseApi.prototype.wheelHandler = function(e) {
      var factor;
      e.preventDefault();
      factor = e.shiftKey ? 1.01 : 1.1;
      this.zoom *= (e.detail || e.wheelDelta) < 0 ? factor : 1 / factor;
      this.zoom = this.zoom > this.maxZoom ? this.maxZoom : this.zoom;
      return this.zoom = this.zoom < this.minZoom ? this.minZoom : this.zoom;
    };

    return BaseApi;

  })();

  this.astro.WebFITS.BaseApi = BaseApi;

  Shaders = {
    vertex: ["attribute vec2 a_position;", "attribute vec2 a_textureCoord;", "uniform vec2 u_offset;", "uniform float u_scale;", "varying vec2 v_textureCoord;", "void main() {", "vec2 position = a_position + u_offset;", "position = position * u_scale;", "gl_Position = vec4(position, 0.0, 1.0);", "v_textureCoord = a_textureCoord;", "}"].join("\n"),
    fragment: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "float arcsinh(float value) {", "return log(value + sqrt(1.0 + value * value));", "}", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = arcsinh(u_extent[0]);", "float max = arcsinh(u_extent[1]);", "float value = arcsinh(pixel_v[0]);", "float pixel = (value - min) / (max - min);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
    lupton: ["precision mediump float;", "uniform sampler2D u_tex1;", "uniform sampler2D u_tex2;", "uniform sampler2D u_tex3;", "uniform float u_gsky;", "uniform float u_rsky;", "uniform float u_isky;", "uniform float u_gscale;", "uniform float u_rscale;", "uniform float u_iscale;", "uniform float u_alpha;", "uniform float u_Q;", "varying vec2 v_textureCoord;", "float arcsinh(float value) {", "return log(value + sqrt(1.0 + value * value));", "}", "void main() {", "vec4 pixel_v_g = texture2D(u_tex1, v_textureCoord);", "vec4 pixel_v_r = texture2D(u_tex2, v_textureCoord);", "vec4 pixel_v_i = texture2D(u_tex3, v_textureCoord);", "float r = (pixel_v_i[0] - u_isky) * u_iscale;", "float g = (pixel_v_r[0] - u_rsky) * u_rscale;", "float b = (pixel_v_g[0] - u_gsky) * u_gscale;", "float I = r + g + b + 1e-10;", "float factor = arcsinh(u_alpha * u_Q * I) / (u_Q * I);", "float R = clamp(r * factor, 0.0, 1.0);", "float G = clamp(g * factor, 0.0, 1.0);", "float B = clamp(b * factor, 0.0, 1.0);", "gl_FragColor = vec4(R, G, B, 1.0);", "}"].join("\n"),
    stiff: ["precision mediump float;", "uniform sampler2D u_tex0;", "uniform sampler2D u_tex1;", "uniform sampler2D u_tex2;", "uniform vec2 u_extremes;", "uniform float u_gscale;", "uniform float u_rscale;", "uniform float u_iscale;", "uniform float u_gsky;", "uniform float u_rsky;", "uniform float u_isky;", "uniform float u_gmax;", "uniform float u_rmax;", "uniform float u_imax;", "uniform float u_alpha;", "uniform float u_Q;", "uniform float u_colorsat;", "varying vec2 v_textureCoord;", "float arcsinh(float value) {", "return log(value + sqrt(1.0 + value * value));", "}", "float lupton_asinh(float mean, float Q, float alpha) {", "return arcsinh(alpha * Q * mean) / (Q * mean);", "}", "void main() {", "vec4 pixel_v_g = texture2D(u_tex0, v_textureCoord);", "vec4 pixel_v_r = texture2D(u_tex1, v_textureCoord);", "vec4 pixel_v_i = texture2D(u_tex2, v_textureCoord);", "float r = pixel_v_i[0] * u_iscale;", "float g = pixel_v_r[0] * u_rscale;", "float b = pixel_v_g[0] * u_gscale;", "float grey = 0.001;", "float gammafac = 1.0;", "float greygf = pow(grey, gammafac);", "float rmin = (u_isky - greygf * u_imax) / (1. - greygf);", "float gmin = (u_rsky - greygf * u_rmax) / (1. - greygf);", "float bmin = (u_gsky - greygf * u_gmax) / (1. - greygf);", "float I = r + g + b + 1e-10;", "float Y = (r + g + b) / 3.0;", "float factor = lupton_asinh(Y, u_Q, u_alpha);", "float R = r * factor;", "float G = g * factor;", "float B = b * factor;", "float R1 = I + u_colorsat * (2.0 * R - G - B);", "float G1 = I + u_colorsat * (2.0 * G - R - B);", "float B1 = I + u_colorsat * (2.0 * B - R - G);", "gl_FragColor = vec4(R1, G1, B1, 1.0);", "}"].join("\n")
  };

  this.astro.WebFITS.Shaders = Shaders;

  BaseApi = this.astro.WebFITS.BaseApi;

  Shaders = this.astro.WebFITS.Shaders;

  Api = (function(_super) {

    __extends(Api, _super);

    function Api() {
      this.wheelHandler = __bind(this.wheelHandler, this);

      this.draw = __bind(this.draw, this);

      this.setBkgdSub = __bind(this.setBkgdSub, this);

      this.setQ = __bind(this.setQ, this);

      this.setAlpha = __bind(this.setAlpha, this);

      this.loadTexture = __bind(this.loadTexture, this);

      this._setRectangle = __bind(this._setRectangle, this);

      this.getContext = __bind(this.getContext, this);
      return Api.__super__.constructor.apply(this, arguments);
    }

    Api.prototype.algorithm = Shaders.lupton;

    Api.prototype.textureIndices = {
      'u': 0,
      'g': 1,
      'r': 2,
      'i': 3,
      'z': 4
    };

    Api.prototype.getContext = function() {
      var buffer, colorShader, context, ext, extentLocation, fragShader, name, offsetLocation, positionLocation, program, scaleLocation, texCoordBuffer, texCoordLocation, vertexShader, _i, _j, _len, _len1, _ref, _ref1;
      _ref = ['webgl', 'experimental-webgl'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        try {
          context = this.canvas.getContext(name);
          context.viewport(0, 0, this.width, this.height);
        } catch (e) {

        }
        if (context) {
          break;
        }
      }
      if (!context) {
        return null;
      }
      this.ctx = context;
      ext = this._getExtension(context);
      if (!ext) {
        return null;
      }
      vertexShader = this._loadShader(context, Shaders.vertex, context.VERTEX_SHADER);
      if (!vertexShader) {
        return null;
      }
      fragShader = this._loadShader(context, Shaders.fragment, context.FRAGMENT_SHADER);
      if (!fragShader) {
        return null;
      }
      colorShader = this._loadShader(context, this.algorithm, context.FRAGMENT_SHADER);
      if (!colorShader) {
        return null;
      }
      this.program1 = this._createProgram(context, [vertexShader, fragShader]);
      if (!this.program1) {
        return null;
      }
      this.program2 = this._createProgram(context, [vertexShader, colorShader]);
      if (!this.program2) {
        return null;
      }
      _ref1 = [this.program2, this.program1];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        program = _ref1[_j];
        context.useProgram(program);
        positionLocation = context.getAttribLocation(program, 'a_position');
        texCoordLocation = context.getAttribLocation(program, 'a_textureCoord');
        extentLocation = context.getUniformLocation(program, 'u_extent');
        offsetLocation = context.getUniformLocation(program, 'u_offset');
        scaleLocation = context.getUniformLocation(program, 'u_scale');
        context.uniform2f(extentLocation, this.minimum, this.maximum);
        context.uniform2f(offsetLocation, -this.width / 2, -this.height / 2);
        context.uniform1f(scaleLocation, 2 / this.width);
      }
      texCoordBuffer = context.createBuffer();
      context.bindBuffer(context.ARRAY_BUFFER, texCoordBuffer);
      context.bufferData(context.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), context.STATIC_DRAW);
      context.enableVertexAttribArray(texCoordLocation);
      context.vertexAttribPointer(texCoordLocation, 2, context.FLOAT, false, 0, 0);
      buffer = context.createBuffer();
      context.bindBuffer(context.ARRAY_BUFFER, buffer);
      context.enableVertexAttribArray(positionLocation);
      context.vertexAttribPointer(positionLocation, 2, context.FLOAT, false, 0, 0);
      this._setRectangle();
      context.drawArrays(context.TRIANGLES, 0, 6);
      return context;
    };

    Api.prototype._getExtension = function(gl) {
      return gl.getExtension('OES_texture_float');
    };

    Api.prototype._loadShader = function(gl, source, type) {
      var compiled, lastError, shader;
      shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!compiled) {
        lastError = gl.getShaderInfoLog(shader);
        throw "Error compiling shader " + shader + ": " + lastError;
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    };

    Api.prototype._createProgram = function(gl, shaders) {
      var linked, program, shader, _i, _len;
      program = gl.createProgram();
      for (_i = 0, _len = shaders.length; _i < _len; _i++) {
        shader = shaders[_i];
        gl.attachShader(program, shader);
      }
      gl.linkProgram(program);
      linked = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!linked) {
        throw "Error in program linking: " + (gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    };

    Api.prototype._setRectangle = function() {
      var x1, x2, y1, y2, _ref, _ref1;
      _ref = [0, 0 + this.width], x1 = _ref[0], x2 = _ref[1];
      _ref1 = [0, 0 + this.height], y1 = _ref1[0], y2 = _ref1[1];
      return this.ctx.bufferData(this.ctx.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), this.ctx.STATIC_DRAW);
    };

    Api.prototype.loadTexture = function(band, data) {
      var index, texture;
      index = this.textureIndices[band];
      this.ctx.activeTexture(this.ctx["TEXTURE" + index]);
      texture = this.ctx.createTexture();
      this.ctx.bindTexture(this.ctx.TEXTURE_2D, texture);
      this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_WRAP_S, this.ctx.CLAMP_TO_EDGE);
      this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_WRAP_T, this.ctx.CLAMP_TO_EDGE);
      this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_MIN_FILTER, this.ctx.NEAREST);
      this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_MAG_FILTER, this.ctx.NEAREST);
      return this.ctx.texImage2D(this.ctx.TEXTURE_2D, 0, this.ctx.LUMINANCE, this.width, this.height, 0, this.ctx.LUMINANCE, this.ctx.FLOAT, data);
    };

    Api.prototype.setScale = function(band, scale) {
      var location;
      this.ctx.useProgram(this.program2);
      location = this.ctx.getUniformLocation(this.program2, "u_" + band + "scale");
      this.ctx.uniform1f(location, scale);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setMax = function(band, max) {
      var location;
      this.ctx.useProgram(this.program2);
      location = this.ctx.getUniformLocation(this.program2, "u_" + band + "max");
      return this.ctx.uniform1f(location, max);
    };

    Api.prototype.setExtent = function(min, max) {
      var location;
      this.ctx.useProgram(this.program1);
      min = (this.MAXIMUM - this.MINIMUM) * min / 1000 + this.MINIMUM;
      max = (this.MAXIMUM - this.MINIMUM) * max / 1000 + this.MINIMUM;
      location = this.ctx.getUniformLocation(this.program1, 'u_extent');
      this.ctx.uniform2f(location, min, max);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setAlpha = function(value) {
      var location;
      this.ctx.useProgram(this.program2);
      location = this.ctx.getUniformLocation(this.program2, 'u_alpha');
      this.ctx.uniform1f(location, value);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setQ = function(value) {
      var location;
      this.ctx.useProgram(this.program2);
      location = this.ctx.getUniformLocation(this.program2, 'u_Q');
      this.ctx.uniform1f(location, value);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setBkgdSub = function(band, value) {
      var location;
      console.warn('TODO: Implement setBkgdSub for grayscale images');
      this.ctx.useProgram(this.program2);
      location = this.ctx.getUniformLocation(this.program2, "u_" + band + "sky");
      this.ctx.uniform1f(location, value);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.draw = function() {
      var offsetLocation, scaleLocation;
      offsetLocation = this.ctx.getUniformLocation(this.currentProgram, 'u_offset');
      scaleLocation = this.ctx.getUniformLocation(this.currentProgram, 'u_scale');
      this.ctx.uniform2f(offsetLocation, this.xOffset, this.yOffset);
      this.ctx.uniform1f(scaleLocation, this.zoom);
      this._setRectangle();
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.drawGrayscale = function(band) {
      var index, location;
      this.ctx.useProgram(this.program1);
      this.currentProgram = this.program1;
      index = this.textureIndices[band];
      this.ctx.activeTexture(this.ctx["TEXTURE" + index]);
      location = this.ctx.getUniformLocation(this.program1, "u_tex");
      this.ctx.uniform1i(location, index);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.drawColor = function() {
      var band, index, location, _i, _len, _ref;
      this.ctx.useProgram(this.program2);
      this.currentProgram = this.program2;
      _ref = ['g', 'r', 'i'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        band = _ref[_i];
        index = this.textureIndices[band];
        this.ctx.activeTexture(this.ctx["TEXTURE" + index]);
        location = this.ctx.getUniformLocation(this.program2, "u_tex" + index);
        this.ctx.uniform1i(location, index);
      }
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.wheelHandler = function(e) {
      var location;
      Api.__super__.wheelHandler.apply(this, arguments);
      location = this.ctx.getUniformLocation(this.program2, 'u_scale');
      this.ctx.uniform1f(location, this.zoom);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    return Api;

  })(BaseApi);

  this.astro.WebFITS.Api = Api;

}).call(this);
