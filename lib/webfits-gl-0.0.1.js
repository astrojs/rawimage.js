// Generated by CoffeeScript 1.4.0
(function() {
  var Api, BaseApi, Shaders, WebFITS,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (this.astro == null) {
    this.astro = {};
  }

  WebFITS = {};

  WebFITS.version = '0.0.1';

  this.astro.WebFITS = WebFITS;

  BaseApi = (function() {

    BaseApi.prototype.steps = 1000;

    function BaseApi(elem, width, height) {
      this.width = width;
      this.height = height;
      this.wheelHandler = __bind(this.wheelHandler, this);

      this.setupMouseInteraction = __bind(this.setupMouseInteraction, this);

      this.canvas = document.createElement('canvas');
      this.canvas.setAttribute('width', this.width);
      this.canvas.setAttribute('height', this.height);
      elem.appendChild(this.canvas);
    }

    BaseApi.prototype.setGlobalExtent = function(MINIMUM, MAXIMUM) {
      this.MINIMUM = MINIMUM;
      this.MAXIMUM = MAXIMUM;
    };

    BaseApi.prototype.setupMouseInteraction = function() {
      var _this = this;
      this.xOffset = -this.width / 2;
      this.yOffset = -this.height / 2;
      this.xOldOffset = this.xOffset;
      this.yOldOffset = this.yOffset;
      this.drag = false;
      this.zoom = 2 / this.width;
      this.minZoom = this.zoom;
      this.maxZoom = 12 * this.zoom;
      this.zoomX = this.zoom;
      this.zoomY = this.zoom;
      this.canvas.onmousedown = function(e) {
        _this.drag = true;
        _this.xOldOffset = _this.xOffset;
        _this.yOldOffset = _this.yOffset;
        _this.xMouseDown = e.clientX;
        return _this.yMouseDown = e.clientY;
      };
      this.canvas.onmouseup = function(e) {
        var xDelta, yDelta;
        _this.drag = false;
        if (_this.xMouseDown == null) {
          return null;
        }
        xDelta = e.clientX - _this.xMouseDown;
        yDelta = e.clientY - _this.yMouseDown;
        _this.xOffset = _this.xOldOffset + (xDelta / _this.width / _this.zoom * 2.0);
        _this.yOffset = _this.yOldOffset - (yDelta / _this.height / _this.zoom * 2.0);
        return _this.draw();
      };
      this.canvas.onmousemove = function(e) {
        var xDelta, yDelta;
        if (!_this.drag) {
          return;
        }
        xDelta = e.clientX - _this.xMouseDown;
        yDelta = e.clientY - _this.yMouseDown;
        _this.xOffset = _this.xOldOffset + (xDelta / _this.width / _this.zoom * 2.0);
        _this.yOffset = _this.yOldOffset - (yDelta / _this.height / _this.zoom * 2.0);
        return _this.draw();
      };
      this.canvas.onmouseout = function(e) {
        return _this.drag = false;
      };
      this.canvas.onmouseover = function(e) {
        return _this.drag = false;
      };
      this.canvas.addEventListener('mousewheel', this.wheelHandler, false);
      return this.canvas.addEventListener('DOMMouseScroll', this.wheelHandler, false);
    };

    BaseApi.prototype.wheelHandler = function(e) {
      var factor;
      e.preventDefault();
      factor = e.shiftKey ? 1.01 : 1.1;
      this.zoom *= (e.detail || e.wheelDelta) < 0 ? factor : 1 / factor;
      this.zoom = this.zoom > this.maxZoom ? this.maxZoom : this.zoom;
      return this.zoom = this.zoom < this.minZoom ? this.minZoom : this.zoom;
    };

    return BaseApi;

  })();

  this.astro.WebFITS.BaseApi = BaseApi;

  Shaders = {
    vertex: ["attribute vec2 a_position;", "attribute vec2 a_textureCoord;", "uniform vec2 u_offset;", "uniform float u_scale;", "varying vec2 v_textureCoord;", "void main() {", "vec2 position = a_position + u_offset;", "position = position * u_scale;", "gl_Position = vec4(position, 0.0, 1.0);", "v_textureCoord = a_textureCoord;", "}"].join("\n"),
    linear: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = u_extent[0];", "float max = u_extent[1];", "float pixel = (pixel_v[0] - min) / (max - min);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
    logarithm: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "float logarithm(float value) {", "return log(value / 0.05 + 1.0) / log(1.0 / 0.05 + 1.0);", "}", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = u_extent[0];", "float max = u_extent[1];", "max = max - min;", "float minScaled = logarithm(0.0);", "max = logarithm(max);", "float pixel = pixel_v[0] - min;", "pixel = logarithm(pixel);", "pixel = (pixel - minScaled) / (max - minScaled);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
    sqrt: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = u_extent[0];", "float max = u_extent[1] - min;", "float pixel = pixel_v[0] - min;", "pixel = sqrt(pixel_v[0] / max);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
    arcsinh: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "float arcsinh(float value) {", "return log(value + sqrt(1.0 + value * value));", "}", "float scaledArcsinh(float value) {", "return arcsinh(value / -0.033) / arcsinh(1.0 / -0.033);", "}", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = scaledArcsinh(u_extent[0]);", "float max = scaledArcsinh(u_extent[1]);", "float value = scaledArcsinh(pixel_v[0]);", "float pixel = (value - min) / (max - min);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
    power: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = u_extent[0];", "float max = u_extent[1] - min;", "float pixel = pixel_v[0] - min;", "pixel = pow(pixel / max, 2.0);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
    fragment: ["precision mediump float;", "uniform sampler2D u_tex;", "uniform vec2 u_extent;", "varying vec2 v_textureCoord;", "float arcsinh(float value) {", "return log(value + sqrt(1.0 + value * value));", "}", "float scaledArcsinh(float value) {", "return arcsinh(value / -0.033) / arcsinh(1.0 / -0.033);", "}", "void main() {", "vec4 pixel_v = texture2D(u_tex, v_textureCoord);", "float min = scaledArcsinh(u_extent[0]);", "float max = scaledArcsinh(u_extent[1]);", "float value = scaledArcsinh(pixel_v[0]);", "float pixel = (value - min) / (max - min);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
    color: ["precision mediump float;", "uniform sampler2D u_tex1;", "uniform sampler2D u_tex2;", "uniform sampler2D u_tex3;", "uniform float u_gscale;", "uniform float u_rscale;", "uniform float u_iscale;", "uniform float u_alpha;", "uniform float u_Q;", "varying vec2 v_textureCoord;", "float arcsinh(float value) {", "return log(value + sqrt(1.0 + value * value));", "}", "void main() {", "vec4 pixel_v_g = texture2D(u_tex1, v_textureCoord);", "vec4 pixel_v_r = texture2D(u_tex2, v_textureCoord);", "vec4 pixel_v_i = texture2D(u_tex3, v_textureCoord);", "float r = (pixel_v_i[0]) * u_iscale;", "float g = (pixel_v_r[0]) * u_rscale;", "float b = (pixel_v_g[0]) * u_gscale;", "float I = r + g + b + 1e-10;", "float factor = arcsinh(u_alpha * u_Q * I) / (u_Q * I);", "float R = clamp(r * factor, 0.0, 1.0);", "float G = clamp(g * factor, 0.0, 1.0);", "float B = clamp(b * factor, 0.0, 1.0);", "gl_FragColor = vec4(R, G, B, 1.0);", "}"].join("\n")
  };

  this.astro.WebFITS.Shaders = Shaders;

  BaseApi = this.astro.WebFITS.BaseApi;

  Shaders = this.astro.WebFITS.Shaders;

  Api = (function(_super) {

    __extends(Api, _super);

    function Api() {
      this.syncVertexUniforms = __bind(this.syncVertexUniforms, this);

      this.wheelHandler = __bind(this.wheelHandler, this);

      this.drawGrayscale = __bind(this.drawGrayscale, this);

      this.draw = __bind(this.draw, this);

      this.setBand = __bind(this.setBand, this);

      this.setStretch = __bind(this.setStretch, this);

      this.setQ = __bind(this.setQ, this);

      this.setAlpha = __bind(this.setAlpha, this);

      this.loadTexture = __bind(this.loadTexture, this);

      this._setRectangle = __bind(this._setRectangle, this);

      this._createProgram = __bind(this._createProgram, this);

      this._getExtension = __bind(this._getExtension, this);

      this.getContext = __bind(this.getContext, this);
      return Api.__super__.constructor.apply(this, arguments);
    }

    Api.prototype.fShaders = ['linear', 'logarithm', 'sqrt', 'arcsinh', 'power', 'color'];

    Api.prototype.algorithm = Shaders.color;

    Api.prototype.programs = {};

    Api.prototype.previousProgram = null;

    Api.prototype.textureIndices = {
      'u': 0,
      'g': 1,
      'r': 2,
      'i': 3,
      'z': 4
    };

    Api.prototype.getContext = function() {
      var buffer, context, ext, extentLocation, fragShader, index, key, name, offsetLocation, positionLocation, program, scaleLocation, texCoordBuffer, texCoordLocation, vertexShader, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      _ref = ['webgl', 'experimental-webgl'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        try {
          context = this.canvas.getContext(name);
          context.viewport(0, 0, this.width, this.height);
        } catch (e) {

        }
        if (context) {
          break;
        }
      }
      if (!context) {
        return null;
      }
      this.ctx = context;
      ext = this._getExtension();
      if (!ext) {
        return null;
      }
      vertexShader = this._loadShader(Shaders.vertex, context.VERTEX_SHADER);
      if (!vertexShader) {
        return null;
      }
      _ref1 = this.fShaders;
      for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
        key = _ref1[index];
        fragShader = this._loadShader(Shaders[key], context.FRAGMENT_SHADER);
        if (!fragShader) {
          return null;
        }
        this.programs[key] = this._createProgram(vertexShader, fragShader);
        if (!this.programs[key]) {
          return null;
        }
      }
      _ref2 = this.programs;
      for (key in _ref2) {
        program = _ref2[key];
        context.useProgram(program);
        positionLocation = context.getAttribLocation(program, 'a_position');
        texCoordLocation = context.getAttribLocation(program, 'a_textureCoord');
        extentLocation = context.getUniformLocation(program, 'u_extent');
        offsetLocation = context.getUniformLocation(program, 'u_offset');
        scaleLocation = context.getUniformLocation(program, 'u_scale');
        context.uniform2f(extentLocation, this.minimum, this.maximum);
        context.uniform2f(offsetLocation, -this.width / 2, -this.height / 2);
        context.uniform1f(scaleLocation, 2 / this.width);
      }
      this.previousProgram = this.programs.linear;
      texCoordBuffer = context.createBuffer();
      context.bindBuffer(context.ARRAY_BUFFER, texCoordBuffer);
      context.bufferData(context.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), context.STATIC_DRAW);
      context.enableVertexAttribArray(texCoordLocation);
      context.vertexAttribPointer(texCoordLocation, 2, context.FLOAT, false, 0, 0);
      buffer = context.createBuffer();
      context.bindBuffer(context.ARRAY_BUFFER, buffer);
      context.enableVertexAttribArray(positionLocation);
      context.vertexAttribPointer(positionLocation, 2, context.FLOAT, false, 0, 0);
      this._setRectangle();
      context.useProgram(this.programs.color);
      context.drawArrays(context.TRIANGLES, 0, 6);
      return context;
    };

    Api.prototype._getExtension = function() {
      return this.ctx.getExtension('OES_texture_float');
    };

    Api.prototype._loadShader = function(source, type) {
      var compiled, lastError, shader;
      shader = this.ctx.createShader(type);
      this.ctx.shaderSource(shader, source);
      this.ctx.compileShader(shader);
      compiled = this.ctx.getShaderParameter(shader, this.ctx.COMPILE_STATUS);
      if (!compiled) {
        lastError = this.ctx.getShaderInfoLog(shader);
        throw "Error compiling shader " + shader + ": " + lastError;
        this.ctx.deleteShader(shader);
        return null;
      }
      return shader;
    };

    Api.prototype._createProgram = function(vshader, fshader) {
      var linked, program, shader, _i, _len, _ref;
      program = this.ctx.createProgram();
      _ref = [vshader, fshader];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        shader = _ref[_i];
        this.ctx.attachShader(program, shader);
      }
      this.ctx.linkProgram(program);
      linked = this.ctx.getProgramParameter(program, this.ctx.LINK_STATUS);
      if (!linked) {
        throw "Error in program linking: " + (this.ctx.getProgramInfoLog(program));
        this.ctx.deleteProgram(program);
        return null;
      }
      return program;
    };

    Api.prototype._setRectangle = function() {
      var x1, x2, y1, y2, _ref, _ref1;
      _ref = [0, 0 + this.width], x1 = _ref[0], x2 = _ref[1];
      _ref1 = [0, 0 + this.height], y1 = _ref1[0], y2 = _ref1[1];
      return this.ctx.bufferData(this.ctx.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), this.ctx.STATIC_DRAW);
    };

    Api.prototype.loadTexture = function(band, data) {
      var index, texture;
      index = this.textureIndices[band];
      this.ctx.activeTexture(this.ctx["TEXTURE" + index]);
      texture = this.ctx.createTexture();
      this.ctx.bindTexture(this.ctx.TEXTURE_2D, texture);
      this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_WRAP_S, this.ctx.CLAMP_TO_EDGE);
      this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_WRAP_T, this.ctx.CLAMP_TO_EDGE);
      this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_MIN_FILTER, this.ctx.NEAREST);
      this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_MAG_FILTER, this.ctx.NEAREST);
      return this.ctx.texImage2D(this.ctx.TEXTURE_2D, 0, this.ctx.LUMINANCE, this.width, this.height, 0, this.ctx.LUMINANCE, this.ctx.FLOAT, data);
    };

    Api.prototype.setScale = function(band, scale) {
      var location;
      this.ctx.useProgram(this.programs['color']);
      location = this.ctx.getUniformLocation(this.programs.color, "u_" + band + "scale");
      this.ctx.uniform1f(location, scale);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setExtent = function(min, max) {
      var location, p, stretch, _i, _len, _ref;
      min = (this.MAXIMUM - this.MINIMUM) * min / this.steps + this.MINIMUM;
      max = (this.MAXIMUM - this.MINIMUM) * max / this.steps + this.MINIMUM;
      _ref = ['linear', 'logarithm', 'sqrt', 'arcsinh', 'power'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stretch = _ref[_i];
        p = this.programs[stretch];
        this.ctx.useProgram(p);
        location = this.ctx.getUniformLocation(p, 'u_extent');
        this.ctx.uniform2f(location, min, max);
      }
      this.ctx.useProgram(this.currentProgram);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setAlpha = function(value) {
      var location;
      this.ctx.useProgram(this.programs.color);
      location = this.ctx.getUniformLocation(this.programs.color, 'u_alpha');
      this.ctx.uniform1f(location, value);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setQ = function(value) {
      var location;
      this.ctx.useProgram(this.programs.color);
      location = this.ctx.getUniformLocation(this.programs.color, 'u_Q');
      this.ctx.uniform1f(location, value);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setStretch = function(value) {
      this.currentProgram = this.previousProgram = this.programs[value];
      this.ctx.useProgram(this.currentProgram);
      return this.draw();
    };

    Api.prototype.setBand = function(band) {
      var index, location;
      this.currentProgram = this.previousProgram;
      this.ctx.useProgram(this.currentProgram);
      this.activeBand = band;
      index = this.textureIndices[band];
      this.ctx.activeTexture(this.ctx["TEXTURE" + index]);
      location = this.ctx.getUniformLocation(this.currentProgram, "u_tex");
      return this.ctx.uniform1i(location, index);
    };

    Api.prototype.draw = function() {
      this.syncVertexUniforms();
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.drawGrayscale = function() {
      return this.draw();
    };

    Api.prototype.drawColor = function() {
      var band, index, location, _i, _len, _ref;
      this.ctx.useProgram(this.programs.color);
      this.currentProgram = this.programs.color;
      this.syncVertexUniforms();
      _ref = ['g', 'r', 'i'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        band = _ref[_i];
        index = this.textureIndices[band];
        this.ctx.activeTexture(this.ctx["TEXTURE" + index]);
        location = this.ctx.getUniformLocation(this.currentProgram, "u_tex" + index);
        this.ctx.uniform1i(location, index);
      }
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.wheelHandler = function(e) {
      var location;
      Api.__super__.wheelHandler.apply(this, arguments);
      location = this.ctx.getUniformLocation(this.currentProgram, 'u_scale');
      this.ctx.uniform1f(location, this.zoom);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.syncVertexUniforms = function() {
      var offsetLocation, scaleLocation;
      offsetLocation = this.ctx.getUniformLocation(this.currentProgram, 'u_offset');
      scaleLocation = this.ctx.getUniformLocation(this.currentProgram, 'u_scale');
      this.ctx.uniform2f(offsetLocation, this.xOffset, this.yOffset);
      return this.ctx.uniform1f(scaleLocation, this.zoom);
    };

    return Api;

  })(BaseApi);

  this.astro.WebFITS.Api = Api;

}).call(this);
