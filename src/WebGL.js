// Generated by CoffeeScript 1.6.3
(function() {
  var Api, BaseApi, ColorMaps, Shaders, version, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseApi = this.astro.WebFITS.BaseApi;

  Shaders = this.astro.WebFITS.Shaders;

  ColorMaps = this.astro.WebFITS.ColorMaps;

  Api = (function(_super) {
    __extends(Api, _super);

    function Api() {
      _ref = Api.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Api.prototype.fShaders = ['linear', 'logarithm', 'sqrt', 'arcsinh', 'power', 'color'];

    Api.prototype.grayMap = 32;

    Api.prototype._getExtension = function() {
      return this.ctx.getExtension('OES_texture_float');
    };

    Api.prototype._loadShader = function(source, type) {
      var compiled, ctx, lastError, shader;
      ctx = this.ctx;
      shader = ctx.createShader(type);
      ctx.shaderSource(shader, source);
      ctx.compileShader(shader);
      compiled = ctx.getShaderParameter(shader, ctx.COMPILE_STATUS);
      if (!compiled) {
        lastError = ctx.getShaderInfoLog(shader);
        throw "Error compiling shader " + shader + ": " + lastError;
        ctx.deleteShader(shader);
        return null;
      }
      this.shaders.push(shader);
      return shader;
    };

    Api.prototype._createProgram = function(vshader, fshader) {
      var ctx, linked, program;
      ctx = this.ctx;
      program = ctx.createProgram();
      ctx.attachShader(program, vshader);
      ctx.attachShader(program, fshader);
      ctx.linkProgram(program);
      linked = ctx.getProgramParameter(program, ctx.LINK_STATUS);
      if (!linked) {
        throw "Error in program linking: " + (ctx.getProgramInfoLog(program));
        ctx.deleteProgram(program);
        return null;
      }
      return program;
    };

    Api.prototype._setRectangle = function(ctx, width, height) {
      var x1, x2, y1, y2, _ref1, _ref2;
      _ref1 = [0, 0 + width], x1 = _ref1[0], x2 = _ref1[1];
      _ref2 = [0, 0 + height], y1 = _ref2[0], y2 = _ref2[1];
      return ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), ctx.STATIC_DRAW);
    };

    Api.prototype._updateUniforms = function(program) {
      var offsetLocation, scaleLocation;
      offsetLocation = this.ctx.getUniformLocation(program, 'u_offset');
      scaleLocation = this.ctx.getUniformLocation(program, 'u_scale');
      this.ctx.uniform2f(offsetLocation, this.xOffset, this.yOffset);
      return this.ctx.uniform1f(scaleLocation, this.zoom);
    };

    Api.prototype.getContext = function() {
      var buffer, colorIndexLocation, ctx, e, ext, fragShader, height, index, key, name, offsetLocation, positionLocation, program, scaleLocation, texCoordBuffer, texCoordLocation, vertexShader, width, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
      _ref1 = ['webgl', 'experimental-webgl'];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        name = _ref1[_i];
        try {
          ctx = this.canvas.getContext(name);
          width = this.canvas.width;
          height = this.canvas.height;
          ctx.viewport(0, 0, width, height);
        } catch (_error) {
          e = _error;
        }
        if (ctx) {
          break;
        }
      }
      if (!ctx) {
        return null;
      }
      this.ctx = ctx;
      ext = this._getExtension();
      if (!ext) {
        return null;
      }
      vertexShader = this._loadShader(Shaders.vertex, ctx.VERTEX_SHADER);
      if (!vertexShader) {
        return null;
      }
      _ref2 = this.fShaders;
      for (index = _j = 0, _len1 = _ref2.length; _j < _len1; index = ++_j) {
        key = _ref2[index];
        fragShader = this._loadShader(Shaders[key], ctx.FRAGMENT_SHADER);
        if (!fragShader) {
          return null;
        }
        this.programs[key] = this._createProgram(vertexShader, fragShader);
        if (!this.programs[key]) {
          return null;
        }
      }
      _ref3 = this.programs;
      for (key in _ref3) {
        program = _ref3[key];
        ctx.useProgram(program);
        positionLocation = ctx.getAttribLocation(program, 'a_position');
        texCoordLocation = ctx.getAttribLocation(program, 'a_textureCoord');
        offsetLocation = ctx.getUniformLocation(program, 'u_offset');
        scaleLocation = ctx.getUniformLocation(program, 'u_scale');
        colorIndexLocation = ctx.getUniformLocation(program, 'uColorMapIndex');
        ctx.uniform2f(offsetLocation, -width / 2, -height / 2);
        ctx.uniform1f(scaleLocation, 2 / width);
        ctx.uniform1f(colorIndexLocation, ColorMaps.binary);
      }
      this.currentProgram = this.programs.linear;
      texCoordBuffer = ctx.createBuffer();
      ctx.bindBuffer(ctx.ARRAY_BUFFER, texCoordBuffer);
      ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), ctx.STATIC_DRAW);
      ctx.enableVertexAttribArray(texCoordLocation);
      ctx.vertexAttribPointer(texCoordLocation, 2, ctx.FLOAT, false, 0, 0);
      buffer = ctx.createBuffer();
      ctx.bindBuffer(ctx.ARRAY_BUFFER, buffer);
      ctx.enableVertexAttribArray(positionLocation);
      ctx.vertexAttribPointer(positionLocation, 2, ctx.FLOAT, false, 0, 0);
      this.buffers.push(texCoordBuffer);
      this.buffers.push(buffer);
      this.setupColorMapTexture();
      return ctx;
    };

    Api.prototype.setupColorMapTexture = function() {
      var ctx, img,
        _this = this;
      ctx = this.ctx;
      this._setRectangle(ctx, 256, 70);
      img = new Image();
      img.onload = function(e) {
        var location, program, stretch, texture, _i, _len, _ref1;
        ctx.activeTexture(ctx.TEXTURE0);
        texture = ctx.createTexture();
        ctx.bindTexture(ctx.TEXTURE_2D, texture);
        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);
        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);
        ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGB, ctx.RGB, ctx.UNSIGNED_BYTE, img);
        _ref1 = ['linear', 'logarithm', 'sqrt', 'arcsinh', 'power'];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          stretch = _ref1[_i];
          program = _this.programs[stretch];
          ctx.useProgram(program);
          location = ctx.getUniformLocation(program, 'uColorMap');
          ctx.uniform1i(location, 0);
        }
        ctx.useProgram(_this.currentProgram);
        return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
      };
      return img.src = "data:image/png;base64," + ColorMaps.base64;
    };

    Api.prototype.setColorMap = function(name) {
      var cmaps, ctx, location, program, stretch, _i, _len, _ref1;
      ctx = this.ctx;
      cmaps = Object.keys(ColorMaps);
      cmaps.shift();
      name = cmaps.indexOf(name) > -1 ? name : 'binary';
      _ref1 = ['linear', 'logarithm', 'sqrt', 'arcsinh', 'power'];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        stretch = _ref1[_i];
        program = this.programs[stretch];
        ctx.useProgram(program);
        location = ctx.getUniformLocation(program, 'uColorMapIndex');
        ctx.uniform1f(location, ColorMaps[name]);
      }
      ctx.useProgram(this.currentProgram);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.loadImage = function(identifier, arr, width, height) {
      var ctx, index, texture;
      ctx = this.ctx;
      if (identifier in this.lookup) {
        index = this.lookup[identifier];
        ctx.activeTexture(ctx.TEXTURE0 + index);
        ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.LUMINANCE, width, height, 0, ctx.LUMINANCE, ctx.FLOAT, new Float32Array(arr));
        return;
      }
      this._setRectangle(ctx, width, height);
      index = this.nImages;
      this.lookup[identifier] = this.nImages;
      ctx.activeTexture(ctx.TEXTURE0 + this.nImages);
      texture = ctx.createTexture();
      ctx.bindTexture(ctx.TEXTURE_2D, texture);
      ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
      ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
      ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);
      ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);
      ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.LUMINANCE, width, height, 0, ctx.LUMINANCE, ctx.FLOAT, new Float32Array(arr));
      if (this.currentImage == null) {
        this.currentImage = identifier;
      }
      this.textures[identifier] = texture;
      return this.nImages += 1;
    };

    Api.prototype.setImage = function(identifier) {
      var index, location;
      index = this.lookup[identifier];
      this.ctx.activeTexture(this.ctx.TEXTURE0 + index);
      location = this.ctx.getUniformLocation(this.currentProgram, "u_tex");
      this.ctx.uniform1i(location, index);
      return this.currentImage = identifier;
    };

    Api.prototype.setStretch = function(stretch) {
      this.currentProgram = this.programs[stretch];
      this.ctx.useProgram(this.currentProgram);
      this.setImage(this.currentImage);
      return this.draw();
    };

    Api.prototype.setExtent = function(min, max) {
      var ctx, location, program, stretch, _i, _len, _ref1;
      ctx = this.ctx;
      _ref1 = ['linear', 'logarithm', 'sqrt', 'arcsinh', 'power'];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        stretch = _ref1[_i];
        program = this.programs[stretch];
        ctx.useProgram(program);
        location = ctx.getUniformLocation(program, 'u_extent');
        ctx.uniform2f(location, min, max);
      }
      ctx.useProgram(this.currentProgram);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setScales = function(r, g, b) {
      var ctx, location, program;
      ctx = this.ctx;
      program = this.programs.color;
      ctx.useProgram(program);
      location = ctx.getUniformLocation(program, "u_r_scale");
      ctx.uniform1f(location, r);
      location = ctx.getUniformLocation(program, "u_g_scale");
      ctx.uniform1f(location, g);
      location = ctx.getUniformLocation(program, "u_b_scale");
      ctx.uniform1f(location, b);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setCalibrations = function(r, g, b) {
      var ctx, location;
      ctx = this.ctx;
      ctx.useProgram(this.programs.color);
      location = ctx.getUniformLocation(this.programs.color, 'u_r_calibration');
      ctx.uniform1f(location, r);
      location = ctx.getUniformLocation(this.programs.color, 'u_g_calibration');
      ctx.uniform1f(location, g);
      location = ctx.getUniformLocation(this.programs.color, 'u_b_calibration');
      ctx.uniform1f(location, b);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setAlpha = function(value) {
      var ctx, location;
      ctx = this.ctx;
      ctx.useProgram(this.programs.color);
      location = ctx.getUniformLocation(this.programs.color, 'u_alpha');
      ctx.uniform1f(location, value);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.setQ = function(value) {
      var ctx, location;
      ctx = this.ctx;
      ctx.useProgram(this.programs.color);
      location = ctx.getUniformLocation(this.programs.color, 'u_Q');
      ctx.uniform1f(location, value);
      return ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.draw = function() {
      this._updateUniforms(this.currentProgram);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.drawColor = function(r, g, b) {
      var ctx, location, program;
      ctx = this.ctx;
      ctx.clear(ctx.COLOR_BUFFER_BIT);
      program = this.currentProgram = this.programs.color;
      ctx.useProgram(program);
      location = ctx.getUniformLocation(program, "u_tex0");
      ctx.uniform1i(location, this.lookup[r]);
      location = ctx.getUniformLocation(program, "u_tex1");
      ctx.uniform1i(location, this.lookup[g]);
      location = ctx.getUniformLocation(program, "u_tex2");
      ctx.uniform1i(location, this.lookup[b]);
      return this.draw();
    };

    Api.prototype.wheelHandler = function(e) {
      var location;
      Api.__super__.wheelHandler.apply(this, arguments);
      location = this.ctx.getUniformLocation(this.currentProgram, 'u_scale');
      this.ctx.uniform1f(location, this.zoom);
      return this.ctx.drawArrays(this.ctx.TRIANGLES, 0, 6);
    };

    Api.prototype.getXOffset = function() {
      return this.xOffset;
    };

    Api.prototype.getYOffset = function() {
      return this.yOffset;
    };

    Api.prototype.getZoom = function() {
      return this.zoom;
    };

    Api.prototype.teardown = function() {
      var buffer, ctx, key, program, shader, texture, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
      ctx = this.ctx;
      _ref1 = this.textures;
      for (key in _ref1) {
        texture = _ref1[key];
        ctx.deleteTexture(texture);
      }
      _ref2 = this.buffers;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        buffer = _ref2[_i];
        ctx.deleteBuffer(buffer);
      }
      _ref3 = this.shaders;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        shader = _ref3[_j];
        ctx.deleteShader(shader);
      }
      _ref4 = this.programs;
      for (key in _ref4) {
        program = _ref4[key];
        ctx.deleteProgram(program);
      }
      this.el.removeChild(this.canvas);
      this.ctx = void 0;
      return this._reset();
    };

    return Api;

  })(BaseApi);

  version = this.astro.WebFITS.version;

  this.astro.WebFITS = Api;

  this.astro.WebFITS.version = version;

}).call(this);
